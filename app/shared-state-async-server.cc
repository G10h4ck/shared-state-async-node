/*
 * Shared State
 *
 * Copyright (c) 2023  Javier Jorge <jjorge@inti.gob.ar>
 * Copyright (c) 2023  Instituto Nacional de Tecnología Industrial
 * Copyright (C) 2023  Gioacchino Mazzurco <gio@eigenlab.org>
 * Copyright (C) 2023  Asociación Civil Altermundi <info@altermundi.net>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */

#include <unistd.h>

#include "io_context.hh"
#include "socket.hh"
#include "task.hh"
#include "sharedstate.hh"
#include "piped_async_command.hh"
#include "debug/rsdebuglevel2.h"
#include "config.h"
#include "sharedstate.hh"


static constexpr int BUFFSIZE = 3048;

using namespace SharedState;

/**
 * @brief this task handles each message. It takes receives a message,
 * calls async cat to implement an echo and returns the same message
 * using the same socket.
 * @param socket
 * @return std::task<bool> returns true if it has not finished or false
 * to finalize the socket and the communication.
 */
std::task<bool> echo_loop(Socket& socket)
{
	NetworkMessage networkMessage;

	co_await receiveNetworkMessage(socket, networkMessage);

	std::string cmd = "/usr/bin/lua /usr/bin/shared-state reqsync";
	cmd = cmd + " " + networkMessage.mTypeName;

	RS_DBG0("executing command -", cmd);

	std::error_condition err;
	std::unique_ptr<PipedAsyncCommand> luaSharedState =
	        PipedAsyncCommand::factory(cmd, socket, &err);

	co_await luaSharedState->writepipe(
	            reinterpret_cast<const uint8_t*>(networkMessage.mData.data()),
	            networkMessage.mData.length() );
	luaSharedState->finishwriting();

	networkMessage.mData.clear();
	networkMessage.mData.resize(DATA_MAX_LENGHT, static_cast<char>(0));

	/* some applications read until eof is sent, the only way is closing the
	 * write end. */
	ssize_t rec_ammount = 0;
	ssize_t nbRecvFromPipe = 0;
	int endlconuter = 0;
	int totalReadBytes = 0;
	uint8_t* dataPtr = reinterpret_cast<uint8_t*>(networkMessage.mData.data());
	do
	{
		nbRecvFromPipe = co_await luaSharedState->readpipe(
		            dataPtr + totalReadBytes, DATA_MAX_LENGHT - totalReadBytes);
		totalReadBytes += nbRecvFromPipe;

		// TODO: should'nt it be == ?
		if (*dataPtr != '\n') endlconuter++;

		RS_DBG0( "nbRecvFromPipe: ", nbRecvFromPipe,
		         ", done reading? ", luaSharedState->doneReading(),
		         " endlconuter: ", endlconuter);
	}
	while (
	       (nbRecvFromPipe != 0) &&
	       (!luaSharedState->doneReading()) &&
	       endlconuter != 1
	      );

	/* read from this pipe in openwrt and using shared state never returns 0 it
	 * just resturns -1. and the donereading flag is always 0
	 * it seems that the second end of line can be a good candidate for end of
	 * transmission */

	luaSharedState->finishReading();

	RS_DBG0( "PIPE contents ...", networkMessage.mData,
	         " .. amount ", rec_ammount );

	// cat and shared state excecve read pipecontents echo the command at the first line
	networkMessage.mData.erase(0, networkMessage.mData.find('\n') + 1);

	co_await sendNetworkMessage(socket, networkMessage);

	co_await luaSharedState->whaitforprocesstodie();
	luaSharedState.reset(nullptr);

	co_return false;
}

/**
 * @brief Handles a client socket until the inside task finishes
 * this can enable a multi message communication over a single socket
 *
 * @param socket a socket generated by accept
 * @return std::task<bool> a task that can be resumed or detached
 */
std::task<bool> client_socket_handler(std::unique_ptr<Socket> socket)
{
    // TODO:can be std::task<void> no need to use bool
    bool run = true;
    while (run)
    {
        RS_DBG0("BEGIN");
        run = co_await echo_loop(*socket);
        RS_DBG0("END");
    }
    socket.reset(nullptr);
    co_return true;
}

std::task<> acceptConnections(ListeningSocket& listener)
{
	while(true)
	{
		auto socket = co_await listener.accept();

		/* Going out of scope the returned task is destroyed, we need to
		 * detach the coroutine otherwise it will be abruptly stopped too before
		 * finishing the job */
		client_socket_handler(std::move(socket)).detach();
	}
}

int main()
{

    RS_DBG0("           ___                         ");
    RS_DBG0("    ____  /   |  _______  ______  _____");
    RS_DBG0("   / __ \\/ /| | / ___/ / / / __ \\/ ___/");
    RS_DBG0("  / / / / ___ |(__  ) /_/ / / / / /__  ");
    RS_DBG0(" /_/ /_/_/  |_/____/\\__, /_/ /_/\\___/  ");
    RS_DBG0("                   /____/              ");
    RS_DBG0("          ver:", PROJECT_VERSION_MAJOR, ".", PROJECT_VERSION_MINOR, ".", PROJECT_VERSION_PATCH, ".", PROJECT_VERSION_TWEAK);

    IOContext io_context{};
	auto listener = ListeningSocket::setupListener(3490, io_context);
	auto t = acceptConnections(*listener.get());
    t.resume();
    io_context.run();
}
