/*
 * Shared State
 *
 * Copyright (c) 2023  Javier Jorge <jjorge@inti.gob.ar>
 * Copyright (c) 2023  Instituto Nacional de Tecnología Industrial
 * Copyright (C) 2023  Gioacchino Mazzurco <gio@eigenlab.org>
 * Copyright (C) 2023  Asociación Civil Altermundi <info@altermundi.net>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */

#include "io_context.hh"
#include "socket.hh"
#include "task.hh"
#include "sharedstate.hh"
#include <iostream>
#include <array>
#include <unistd.h>
#include "piped_async_command.hh"
#include "debug/rsdebuglevel2.h"
#include "config.h"

#define BUFFSIZE 256

/**
 * @brief this task handles each message. It takes receives a message, 
 * calls async cat to implement an echo and returns the same message 
 * using the same socket.
 * @param socket 
 * @return std::task<bool> returns true if it has not finished or false 
 * to finalize the socket and the communication.
 */
std::task<bool> echo_loop(Socket &socket)
{
    char socbuffer[BUFFSIZE] = {0};
    // TODO: lo que no entra en el buffer se procesa como otro mensaje...?
    ssize_t nbRecv = co_await socket.recv((uint8_t*)socbuffer, (sizeof socbuffer) - 1);
    
    if (nbRecv <= 0) //todo: if the maximum amount has been received copy to a buffer ?
    {
        co_return false; 
    }
    RS_DBG0("RECIVING (" , socbuffer , "):" );
    std::array<uint8_t, BUFFSIZE> buffer;
    std::string merged;
    std::string cmd = "cat";
    std::error_condition err;
    std::unique_ptr<PipedAsyncCommand> asyncecho = PipedAsyncCommand::factory(cmd, &socket,err);
    if (err != std::errc())
    {
        asyncecho.reset(nullptr);
        co_return false;
    }
    co_await asyncecho->writepipe((uint8_t*)socbuffer, nbRecv);
    RS_DBG0("writepipe (" , socbuffer , "):" );
    co_await asyncecho->readpipe(buffer.data(), BUFFSIZE);
    
    merged = (char *)buffer.data();
    RS_DBG0("readpipe (" , merged , "):" );
    // problema de manejo de errores... que pasa cuando se cuelgan los endpoints y ya no reciben.

    size_t nbSend = 0;
    while (nbSend < merged.size()) // todo: probar y hacer un pull request al creador
    {
        RS_DBG0("SENDING (" , merged , "):" );
        ssize_t res = co_await socket.send((uint8_t*)&(merged.data()[nbSend]), merged.size() - nbSend);
        if (res <= 0)
        {
            RS_DBG0("DONE (" , nbRecv , "):" );
            co_return false;
        }
        nbSend += res;
    }
    // TODO: esto va al std error ?? SERA QUE PODEMOS USAR UNA LIBRERIA DE LOGGFILE
    RS_DBG0("DONE (" , nbRecv , "):" );
    co_await asyncecho->whaitforprocesstodie();
    asyncecho.reset(nullptr);
    co_return false;
}

/**
 * @brief Handles a client socket until the inside task finishes
 * this can enable a multi message communication over a single socket
 * 
 * @param socket a socket generated by accept
 * @return std::task<bool> a task that can be resumed or detached 
 */
std::task<bool> client_socket_handler(std::unique_ptr<Socket> socket)
{
    //TODO:can be std::task<void> no need to use bool
    bool run = true;
    while (run)
    {
        RS_DBG0("BEGIN");
        run = co_await echo_loop(*socket);
        RS_DBG0("END");
    }
    socket.reset(nullptr);
    co_return true;
}

std::task<> accept(Socket &listen)
{
	while(true)
	{
		RS_DBG0("begin accept");
		auto socket = co_await listen.accept();

		/* Going out of scope the returned task is destroyed, we need to
		 * detach the coroutine otherwise it will be abruptly stopped too before
		 * finishing the job */
		client_socket_handler(std::move(socket)).detach();

		RS_DBG0("end accept");
	}
}

int main()
{
    
RS_DBG0("           _        _            ____                           ");
RS_DBG0("  _ __    / \\   ___(_)_ __   ___/ ___|  ___ _ ____   _____ _ __ ");
RS_DBG0(" | '_ \\  / _ \\ / __| | '_ \\ / __\\___ \\ / _ | '__\\ \\ / / _ | '__|");
RS_DBG0(" | | | |/ ___ \\ __ | | | | | (__ ___) |  __| |   \\ V |  __| |   ");
RS_DBG0(" |_| |_/_/   \\_|___|_|_| |_|\\___|____/ \\___|_|    \\_/ \\___|_|   ");
RS_DBG0("                        ver:",PROJECT_VERSION_MAJOR,".",PROJECT_VERSION_MINOR,".",PROJECT_VERSION_PATCH,".",PROJECT_VERSION_TWEAK);
RS_DBG0("");
    IOContext io_context{};
    Socket listen{"3490", io_context};
    auto t = accept(listen);
    t.resume();
    io_context.run();
}
