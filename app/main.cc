/*
 * Shared State
 *
 * Copyright (c) 2023  Javier Jorge <jjorge@inti.gob.ar>
 * Copyright (c) 2023  Instituto Nacional de Tecnología Industrial
 * Copyright (C) 2023  Gioacchino Mazzurco <gio@eigenlab.org>
 * Copyright (C) 2023  Asociación Civil Altermundi <info@altermundi.net>
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 */

#include "io_context.hh"
#include "socket.hh"
#include "task.hh"
#include "sharedstate.hh"
#include <iostream>
#include <array>
#include <unistd.h>
#include "piped_async_command.hh"
#include "debug/rsdebuglevel2.h"
#include "config.h"

#define BUFFSIZE 3048

/**
 * @brief this task handles each message. It takes receives a message, 
 * calls async cat to implement an echo and returns the same message 
 * using the same socket.
 * @param socket 
 * @return std::task<bool> returns true if it has not finished or false 
 * to finalize the socket and the communication.
 */
std::task<bool> echo_loop(Socket &socket)
{
    char socbuffer[BUFFSIZE] = {0};
    // TODO: lo que no entra en el buffer se procesa como otro mensaje...?
    ssize_t nbRecv = co_await socket.recv((uint8_t*)socbuffer, (sizeof socbuffer) - 1);
    
    if (nbRecv <= 0) //todo: if the maximum amount has been received copy to a buffer ?
    {
        co_return false; 
    }
    RS_DBG0("RECIVING (" , socbuffer , "):" );
    std::array<uint8_t, BUFFSIZE> buffer;
    buffer.fill(0);
    std::string data = socbuffer;
    std::string command = SharedState::extractCommand(data);
    std::string merged;
    std::string cmd = "/usr/bin/lua /usr/bin/shared-state reqsync ";
    //std::string cmd = "/tmp/scandir.lua ls ";
    RS_DBG0("executing command -",cmd);
    cmd = "cat";
    //cmd = cmd + command;
    RS_DBG0("executing command -",cmd);
    std::error_condition err;
    std::unique_ptr<PipedAsyncCommand> asyncecho = PipedAsyncCommand::factory(cmd, &socket,err);
    if (err != std::errc())
    {
        asyncecho.reset(nullptr); 
        RS_ERR("Error creating new process....");
        co_return false;  
    }
    co_await asyncecho->writepipe(reinterpret_cast<const uint8_t*>(&data[0]), data.length());
    RS_DBG0("writepipe (" , data , ")" );
    //some applications read until eof is sent, the only way is closing the write end.
    asyncecho->finishwriting();
 
    ssize_t nbRecvFromPipe = co_await asyncecho->readpipe(buffer.data(), BUFFSIZE);
    merged += (char *)buffer.data();
    RS_DBG0("readpipe aaaaaaaaaaaaaaaa (" , merged , ") ammount" ,nbRecvFromPipe);
    //in the case of shared-state an extra read is necesary to bring command output
    //when testing with cat sometimes the extra read hangs and no new notification arrives 
    //nbRecvFromPipe += co_await asyncecho->readpipe(buffer.data(), BUFFSIZE);
    //merged += (char *)buffer.data();
    //RS_DBG0("readpipe bbbbbbbbbbbbbbbbbb (" , merged , ") ammount" ,nbRecvFromPipe);

    //TODO: problema de manejo de errores... que pasa cuando se cuelgan los endpoints y ya no reciben.

    size_t nbSend = 0;
    while (nbSend < nbRecvFromPipe) // todo: probar y hacer un pull request al creador
    {
        RS_DBG0("SENDING (" , merged , "):" );
        ssize_t res = co_await socket.send((uint8_t*)&(merged.data()[nbSend]), nbRecvFromPipe - nbSend); 
        //todo: add error handling to avoid program interruption due to socket malfunction
        if (res <= 0)
        {
            RS_DBG0("DONE (" , nbRecvFromPipe , "):" );
            co_return false;
        }
        nbSend += res;
    }
    asyncecho->finishReading();
    // TODO: esto va al std error ?? SERA QUE PODEMOS USAR UNA LIBRERIA DE LOGGFILE
    RS_DBG0("DONE (" , nbRecvFromPipe , "):" );
    co_await asyncecho->whaitforprocesstodie();
    asyncecho.reset(nullptr);
    co_return false;
}

/**
 * @brief Handles a client socket until the inside task finishes
 * this can enable a multi message communication over a single socket
 * 
 * @param socket a socket generated by accept
 * @return std::task<bool> a task that can be resumed or detached 
 */
std::task<bool> client_socket_handler(std::unique_ptr<Socket> socket)
{
    //TODO:can be std::task<void> no need to use bool
    bool run = true;
    while (run)
    {
        RS_DBG0("BEGIN");
        run = co_await echo_loop(*socket);
        RS_DBG0("END");
    }
    socket.reset(nullptr);
    co_return true;
}

std::task<> accept(Socket &listen)
{
	while(true)
	{
		RS_DBG0("begin accept");
		auto socket = co_await listen.accept();

		/* Going out of scope the returned task is destroyed, we need to
		 * detach the coroutine otherwise it will be abruptly stopped too before
		 * finishing the job */
		client_socket_handler(std::move(socket)).detach();

		RS_DBG0("end accept");
	}
}

int main()
{

RS_DBG0("           ___                         ");
RS_DBG0("    ____  /   |  _______  ______  _____");
RS_DBG0("   / __ \\/ /| | / ___/ / / / __ \\/ ___/");
RS_DBG0("  / / / / ___ |(__  ) /_/ / / / / /__  ");
RS_DBG0(" /_/ /_/_/  |_/____/\\__, /_/ /_/\\___/  ");
RS_DBG0("                   /____/              ");
RS_DBG0("          ver:",PROJECT_VERSION_MAJOR,".",PROJECT_VERSION_MINOR,".",PROJECT_VERSION_PATCH,".",PROJECT_VERSION_TWEAK);


    IOContext io_context{};
    Socket listen{"3490", io_context};
    auto t = accept(listen);
    t.resume();
    io_context.run();
}
